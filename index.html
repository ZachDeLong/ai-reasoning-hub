<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Reasoning Hub</title>
  <!-- 1. Load Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com?plugins=typography"></script>
  <!-- 2. Load React libraries -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <!-- 3. Load Babel to transpile JSX in the browser -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- 4. Load Marked.js to render Markdown -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <!-- 5. Load DOMPurify to sanitize HTML and prevent XSS -->
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>


  <style>
    /* Basic font setup */
    body {
      font-family: 'Inter', sans-serif;
    }

    /* Add a dark mode class to the html tag if the user prefers it */
    .dark body {
      background-color: #111827;
      /* gray-900 */
    }

    /* Simple scrollbar styling for Chrome/Safari */
    ::-webkit-scrollbar {
      width: 10px;
      height: 10px;
    }

    ::-webkit-scrollbar-thumb {
      background: #9ca3af;
      /* gray-400 */
      border-radius: 10px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: #6b7280;
      /* gray-500 */
    }

    ::-webkit-scrollbar-track {
      background: #f3f4f6;
      /* gray-100 */
    }

    .dark ::-webkit-scrollbar-track {
      background: #1f2937;
      /* gray-800 */
    }
  </style>
</head>

<body>
  <!-- 4. This is the root element where our React app will be mounted -->
  <div id="root"></div>


  <!-- 5. This is our entire React application, written in JSX -->
  <!-- We mark it as "text/babel" so the Babel library can transpile it -->
  <script type="text/babel">
    const { useState, useMemo, useCallback, useEffect } = React;


    // --- Constants ---
    const CARDS_PER_PAGE = 15;
    const BREAKDOWN_MAX = { "Novelty": 3, "Utility": 1, "Results": 2, "Access": 1 };

    // --- Utils ---


    /**
     * Gets a Tailwind color class based on the score (ported from Python)
     */
    const getScoreColor = (s) => {
      if (s >= 7) return "text-blue-500 border-blue-500"; // Perfect
      if (s >= 6) return "text-green-600 border-green-600"; // Excellent
      if (s >= 5) return "text-green-500 border-green-500"; // Very Good
      if (s >= 4) return "text-lime-500 border-lime-500"; // Good
      if (s >= 3) return "text-yellow-500 border-yellow-500"; // Average
      if (s >= 2) return "text-orange-500 border-orange-500"; // Below Average
      return "text-red-500 border-red-500"; // Poor
    };


    /**
     * Parses the breakdown string "Novelty: 3, Impact: 4" into an object
     */
    const parseBreakdown = (breakdown) => {
      const parts = {};
      if (!breakdown) return parts;

      breakdown.split(",").forEach(kv => {
        if (kv.includes(":")) {
          const [k, v] = kv.split(":");
          try {
            parts[k.trim()] = parseInt(v.trim(), 10);
          } catch (e) {
            parts[k.trim()] = 0;
          }
        }
      });
      return parts;
    };


    // --- Icon Components (Inline SVGs) ---


    const SearchIcon = () => (
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <circle cx="11" cy="11" r="8"></circle>
        <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
      </svg>
    );


    const ChevronDownIcon = () => (
      <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <polyline points="6 9 12 15 18 9"></polyline>
      </svg>
    );


    const ChevronRightIcon = () => (
      <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <polyline points="9 18 15 12 9 6"></polyline>
      </svg>
    );


    // --- UI Components ---


    /**
     * A custom switch toggle component
     */
    const CustomSwitch = ({ label, isChecked, onChange }) => {
      return (
        <label className="flex items-center justify-between cursor-pointer">
          <span className="text-sm font-medium text-gray-700 dark:text-gray-300">{label}</span>
          <button
            type="button"
            role="switch"
            aria-checked={isChecked}
            onClick={onChange}
            className={`${isChecked ? 'bg-blue-600' : 'bg-gray-200 dark:bg-gray-700'
              } relative inline-flex h-6 w-11 flex-shrink-0 cursor-pointer rounded-full border-2 border-transparent transition-colors duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2`}
          >
            <span
              aria-hidden="true"
              className={`${isChecked ? 'translate-x-5' : 'translate-x-0'
                } pointer-events-none inline-block h-5 w-5 transform rounded-full bg-white shadow ring-0 transition duration-200 ease-in-out`}
            />
          </button>
        </label>
      );
    };


    /**
     * A custom segmented control for sorting
     */
    const SortToggle = ({ options, selected, onChange }) => {
      return (
        <div className="flex w-full rounded-lg bg-gray-100 dark:bg-gray-800 p-1">
          {options.map(opt => (
            <button
              key={opt.value}
              onClick={() => onChange(opt.value)}
              className={`flex-1 rounded-md px-3 py-1.5 text-sm font-semibold transition-all
               ${selected === opt.value
                  ? 'bg-white dark:bg-gray-700 text-blue-600 dark:text-blue-400 shadow-sm'
                  : 'text-gray-600 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-gray-700'
                }
             `}
            >
              {opt.label}
            </button>
          ))}
        </div>
      );
    };


    /**
     * An expandable section for summary and PDF
     */
    const ExpandableSection = ({ title, children, startOpen = false }) => {
      const [isOpen, setIsOpen] = useState(startOpen);


      return (
        <div className="border-t border-gray-200 dark:border-gray-700">
          <button
            onClick={() => setIsOpen(!isOpen)}
            className="flex w-full items-center justify-between py-3 text-left font-medium text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-300"
          >
            <span>{title}</span>
            {isOpen ? <ChevronDownIcon /> : <ChevronRightIcon />}
          </button>
          {isOpen && (
            <div className="pb-4 prose prose-sm dark:prose-invert max-w-none">
              {typeof children === 'string' ? (
                <div dangerouslySetInnerHTML={{ __html: DOMPurify.sanitize(marked.parse(children)) }} />
              ) : (
                children
              )}
            </div>
          )}
        </div>
      );
    };


    /**
     * The new visual score donut
     */
    const ScoreDonut = ({ score }) => {
      if (score === 0) {
        return (
          <div className="flex flex-col items-center justify-center w-24 h-24 rounded-full border-4 border-gray-300 dark:border-gray-600 bg-gray-50 dark:bg-gray-800 flex-shrink-0">
            <span className="text-3xl font-bold text-gray-400 dark:text-gray-500">‚Äî</span>
            <span className="text-xs font-medium text-gray-400 dark:text-gray-500">N/A</span>
          </div>
        );
      }


      const colorClasses = getScoreColor(score);

      return (
        <div className={`flex flex-col items-center justify-center w-24 h-24 rounded-full border-8 bg-white dark:bg-gray-800 flex-shrink-0 ${colorClasses}`}>
          <span className="text-3xl font-bold">{score}</span>
          <span className="text-xs font-medium -mt-1">/ 7</span>
        </div>
      );
    };


    /**
     * The new visual score breakdown
     */
    const BreakdownVisual = ({ breakdownString }) => {
      const breakdown = parseBreakdown(breakdownString);
      const labels = ["Novelty", "Utility", "Results", "Access"];


      return (
        <div className="space-y-2">
          {labels.map(label => {
            const score = breakdown[label] || 0;
            const max = BREAKDOWN_MAX[label] || 0;
            if (max === 0) return null;


            return (
              <div key={label}>
                <div className="flex justify-between items-center mb-0.5">
                  <span className="text-xs font-medium text-gray-600 dark:text-gray-400">{label}</span>
                  <span className="text-xs font-semibold text-gray-800 dark:text-gray-200">{score}/{max}</span>
                </div>
                <div className="flex space-x-1">
                  {Array.from({ length: max }).map((_, i) => (
                    <div
                      key={i}
                      className={`h-2 flex-1 rounded-sm ${i < score ? 'bg-blue-500' : 'bg-gray-200 dark:bg-gray-600'
                        }`}
                    />
                  ))}
                </div>
              </div>
            );
          })}
        </div>
      );
    };


    /**
     * Reading list dropdown component
     */
    const ReadingListDropdown = ({ currentList, listNames, onSelectList }) => {
      const [isOpen, setIsOpen] = useState(false);

      return (
        <div className="relative">
          <button
            onClick={() => setIsOpen(!isOpen)}
            className={`flex items-center gap-1 px-2 py-1 text-xs font-medium rounded transition-colors ${
              currentList
                ? 'bg-blue-100 dark:bg-blue-900 text-blue-700 dark:text-blue-300'
                : 'bg-gray-100 dark:bg-gray-700 text-gray-600 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-gray-600'
            }`}
          >
            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
              <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path>
              <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>
            </svg>
            {currentList || 'Add to list'}
          </button>
          {isOpen && (
            <>
              <div className="fixed inset-0 z-10" onClick={() => setIsOpen(false)} />
              <div className="absolute right-0 mt-1 w-36 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg shadow-lg z-20">
                {listNames.map(name => (
                  <button
                    key={name}
                    onClick={() => {
                      onSelectList(name === currentList ? null : name);
                      setIsOpen(false);
                    }}
                    className={`w-full text-left px-3 py-2 text-sm hover:bg-gray-100 dark:hover:bg-gray-700 first:rounded-t-lg last:rounded-b-lg ${
                      name === currentList ? 'bg-blue-50 dark:bg-blue-900/50 text-blue-600 dark:text-blue-400' : 'text-gray-700 dark:text-gray-300'
                    }`}
                  >
                    {name}
                  </button>
                ))}
                {currentList && (
                  <>
                    <div className="border-t border-gray-200 dark:border-gray-700" />
                    <button
                      onClick={() => {
                        onSelectList(null);
                        setIsOpen(false);
                      }}
                      className="w-full text-left px-3 py-2 text-sm text-red-600 dark:text-red-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-b-lg"
                    >
                      Remove from list
                    </button>
                  </>
                )}
              </div>
            </>
          )}
        </div>
      );
    };

    /**
     * Bookmark star icon component
     */
    const BookmarkStar = ({ isBookmarked, onClick }) => (
      <button
        onClick={onClick}
        className={`p-1.5 rounded-full transition-all ${
          isBookmarked
            ? 'text-yellow-500 hover:text-yellow-600'
            : 'text-gray-400 hover:text-yellow-500'
        }`}
        title={isBookmarked ? 'Remove bookmark' : 'Add bookmark'}
      >
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="20"
          height="20"
          viewBox="0 0 24 24"
          fill={isBookmarked ? 'currentColor' : 'none'}
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
        </svg>
      </button>
    );

    /**
     * The main component for displaying a single paper card
     */
    const PaperCard = ({ paper, isBookmarked, onToggleBookmark, currentList, listNames, onSelectList }) => {
      const [showPdf, setShowPdf] = useState(false);

      const score = paper.excitement_score || 0;
      const assessment = (paper.excitement_reasoning || "").trim();


      return (
        <div className="bg-white dark:bg-gray-800 shadow-lg rounded-xl overflow-hidden transition-all duration-300 hover:shadow-xl border border-gray-200 dark:border-gray-700">
          <div className="p-5 flex flex-col md:flex-row gap-5">

            {/* Left Column: Score, Breakdown & Bookmark */}
            <div className="flex flex-col items-center md:w-32 flex-shrink-0 space-y-4">
              <ScoreDonut score={score} />
              {score > 0 && <BreakdownVisual breakdownString={paper.score_breakdown} />}
              {paper.arxiv_id && (
                <div className="flex flex-col items-center gap-2">
                  <BookmarkStar
                    isBookmarked={isBookmarked}
                    onClick={() => onToggleBookmark(paper.arxiv_id)}
                  />
                  <ReadingListDropdown
                    currentList={currentList}
                    listNames={listNames}
                    onSelectList={(list) => onSelectList(paper.arxiv_id, list)}
                  />
                </div>
              )}
            </div>

            {/* Right Column: Content */}
            <div className="flex-1 min-w-0">
              {/* Header: Title & Authors */}
              <a
                href={paper.arxiv_link}
                target="_blank"
                rel="noopener noreferrer"
                className="text-lg font-bold text-gray-900 dark:text-white hover:text-blue-600 dark:hover:text-blue-400"
              >
                {paper.title}
              </a>
              <p className="text-sm text-gray-500 dark:text-gray-400 mt-1 italic truncate" title={paper.authors}>
                {paper.authors}
              </p>

              {/* Meta: Date & Category & BibTeX */}
              <div className="flex flex-wrap items-center gap-x-3 gap-y-1 text-xs text-gray-600 dark:text-gray-400 mt-2">
                <span>{paper.date}</span>
                {paper.reasoning_category && (
                  <React.Fragment>
                    <span>‚Ä¢</span>
                    <span className="font-medium px-2 py-0.5 bg-gray-100 dark:bg-gray-700 rounded-full">{paper.reasoning_category}</span>
                  </React.Fragment>
                )}
                {paper.arxiv_id && (
                  <React.Fragment>
                    <span>‚Ä¢</span>
                    <button
                      onClick={async () => {
                        try {
                          const resp = await fetch(`/api/bibtex/${paper.arxiv_id}`);
                          const bibtex = await resp.text();
                          await navigator.clipboard.writeText(bibtex);
                          alert('BibTeX copied to clipboard!');
                        } catch (e) {
                          console.error('Failed to copy BibTeX:', e);
                        }
                      }}
                      className="font-medium px-2 py-0.5 bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 rounded-full transition-colors cursor-pointer"
                    >
                      Copy BibTeX
                    </button>
                  </React.Fragment>
                )}
              </div>

              {/* TLDR */}
              {paper.tldr && (
                <blockquote className="mt-4 p-3 bg-gray-50 dark:bg-gray-700 border-l-4 border-gray-300 dark:border-gray-600 rounded-r-md">
                  <p className="text-sm text-gray-700 dark:text-gray-300">
                    {paper.tldr}
                  </p>
                </blockquote>
              )}

              {/* Assessment */}
              {assessment && (
                <div className="mt-4">
                  <h4 className="font-semibold text-gray-800 dark:text-gray-200">Assessment</h4>
                  <p className="text-sm text-gray-600 dark:text-gray-400 mt-1">
                    {assessment}
                  </p>
                </div>
              )}


              {/* Expandable Summary & PDF */}
              <div className="mt-4 space-y-2">
                {paper.summary_md && (
                  <ExpandableSection title="Show full summary">
                    {/* This will now be rendered as rich HTML */
                      paper.summary_md
                    }
                  </ExpandableSection>
                )}

                {paper.arxiv_id && (
                  <ExpandableSection title="Show PDF">
                    <iframe
                      src={`/api/pdf/${paper.arxiv_id}`}
                      width="100%"
                      height="600"
                      className="border border-gray-300 dark:border-gray-700 rounded-md"
                      title={`${paper.title} PDF`}
                    />
                  </ExpandableSection>
                )}
              </div>
            </div>
          </div>
        </div>
      );
    };


    /**
     * The sticky filter sidebar
     */
    const FilterSidebar = ({ filters, setFilters, allCategories, resultsCount, darkMode, setDarkMode, bookmarkCount, listNames, getListCount }) => {

      const handleFilterChange = (key, value) => {
        setFilters(prev => ({ ...prev, [key]: value }));
      };


      const toggleCategory = (category) => {
        setFilters(prev => {
          const newCats = new Set(prev.selectedCategories);
          if (newCats.has(category)) {
            newCats.delete(category);
          } else {
            newCats.add(category);
          }
          return { ...prev, selectedCategories: newCats };
        });
      };

      // debounce search input so there isnt a new API request every keystroke
      const debounce = (func, delay) => {
        let timeout;
        return (...args) => {
          clearTimeout(timeout);
          timeout = setTimeout(() => {
            func.apply(this, args);
          }, delay);
        };
      };

      // debounced version of filter change function
      // only updates the state and trigger an API call 300ms after typing stops
      const debouncedSearchChange = useCallback(
        debounce((value) => handleFilterChange('search', value), 300),
        []
      );

      const debouncedAuthorChange = useCallback(
        debounce((value) => handleFilterChange('author', value), 300),
        []
      );


      return (
        <div className="w-full md:w-80 lg:w-96 flex-shrink-0 md:h-screen md:sticky top-0 overflow-y-auto bg-gray-50 dark:bg-gray-900 border-r border-gray-200 dark:border-gray-700 p-5">
          <div className="flex items-center justify-between">
            <div className="flex items-baseline gap-3">
              <h2 className="text-2xl font-bold text-gray-900 dark:text-white">Reasoning Hub</h2>
              <a href="/about" className="text-sm font-medium text-blue-600 dark:text-blue-400 hover:underline">About</a>
            </div>
            <button
              onClick={() => setDarkMode(!darkMode)}
              className="p-2 rounded-lg bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors"
              title={darkMode ? "Switch to light mode" : "Switch to dark mode"}
            >
              {darkMode ? '‚òÄÔ∏è' : 'üåô'}
            </button>
          </div>
          <p className="text-sm text-gray-600 dark:text-gray-400 mt-1 mb-6">
            Showing {resultsCount} results
          </p>


          <div className="space-y-6">
            {/* Search */}
            <div>
              <label htmlFor="search" className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-1.5">Search</label>
              <div className="relative">
                <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                  <span className="text-gray-400"><SearchIcon /></span>
                </div>
                <input
                  type="text"
                  id="search"
                  defaultValue={filters.search}
                  onChange={e => debouncedSearchChange(e.target.value)}
                  placeholder="Search title, tldr, summary..."
                  className="w-full pl-10 pr-4 py-2 rounded-lg border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                />
              </div>
            </div>

            {/* Author Search */}
            <div>
              <label htmlFor="author" className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-1.5">Author</label>
              <input
                type="text"
                id="author"
                defaultValue={filters.author}
                onChange={e => debouncedAuthorChange(e.target.value)}
                placeholder="Search by author name..."
                className="w-full px-4 py-2 rounded-lg border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
              />
            </div>

            {/* Date Range */}
            <div>
              <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-1.5">Date Range</label>
              <div className="flex items-center gap-2">
                <input
                  type="date"
                  value={filters.dateFrom}
                  onChange={e => handleFilterChange('dateFrom', e.target.value)}
                  className="flex-1 px-3 py-2 rounded-lg border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 text-gray-900 dark:text-white text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
                />
                <span className="text-gray-500 dark:text-gray-400 text-sm">to</span>
                <input
                  type="date"
                  value={filters.dateTo}
                  onChange={e => handleFilterChange('dateTo', e.target.value)}
                  className="flex-1 px-3 py-2 rounded-lg border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 text-gray-900 dark:text-white text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
                />
              </div>
            </div>

            {/* Sort */}
            <div>
              <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-1.5">Sort by</label>
              <SortToggle
                options={[
                  { label: 'Newest', value: 'newest' },
                  { label: 'Score', value: 'score' },
                ]}
                selected={filters.sort}
                onChange={val => handleFilterChange('sort', val)}
              />
            </div>


            {/* Toggles */}
            <div className="space-y-3">
              <CustomSwitch
                label="Summarized Only"
                isChecked={filters.onlySummarized}
                onChange={() => handleFilterChange('onlySummarized', !filters.onlySummarized)}
              />
              <CustomSwitch
                label="Scored Only"
                isChecked={filters.onlyScored}
                onChange={() => handleFilterChange('onlyScored', !filters.onlyScored)}
              />
              <CustomSwitch
                label={`Bookmarked Only (${bookmarkCount})`}
                isChecked={filters.onlyBookmarked}
                onChange={() => handleFilterChange('onlyBookmarked', !filters.onlyBookmarked)}
              />
            </div>


            {/* Min Score Slider */}
            <div>
              <label htmlFor="minScore" className="flex justify-between text-sm font-semibold text-gray-700 dark:text-gray-300 mb-1.5">
                <span>Min excitement score</span>
                <span className="font-bold text-blue-600 dark:text-blue-400">{filters.minScore} / 7</span>
              </label>
              <input
                type="range"
                id="minScore"
                min="0"
                max="7"
                step="1"
                value={filters.minScore}
                onChange={e => handleFilterChange('minScore', parseInt(e.target.value, 10))}
                className="w-full h-2 bg-gray-200 dark:bg-gray-700 rounded-lg appearance-none cursor-pointer accent-blue-600"
              />
            </div>

            {/* Categories */}
            <div>
              <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-1.5">Categories</label>


              <div className="flex flex-wrap gap-2">
                {allCategories.map(cat => (
                  <button
                    key={cat}
                    onClick={() => toggleCategory(cat)}
                    className={`px-3 py-1 text-sm font-medium rounded-full transition-all
                     ${filters.selectedCategories.has(cat)
                        ? 'bg-blue-600 text-white'
                        : 'bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-600'
                      }
                   `}
                  >
                    {cat}
                  </button>
                ))}
              </div>
            </div>

            {/* Reading Lists */}
            <div>
              <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-1.5">Reading Lists</label>
              <div className="flex flex-wrap gap-2">
                <button
                  onClick={() => handleFilterChange('selectedList', null)}
                  className={`px-3 py-1 text-sm font-medium rounded-full transition-all
                    ${!filters.selectedList
                      ? 'bg-blue-600 text-white'
                      : 'bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-600'
                    }
                  `}
                >
                  All
                </button>
                {listNames.map(name => (
                  <button
                    key={name}
                    onClick={() => handleFilterChange('selectedList', filters.selectedList === name ? null : name)}
                    className={`px-3 py-1 text-sm font-medium rounded-full transition-all
                      ${filters.selectedList === name
                        ? 'bg-blue-600 text-white'
                        : 'bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-600'
                      }
                    `}
                  >
                    {name} ({getListCount(name)})
                  </button>
                ))}
              </div>
            </div>

            {/* Export & Share Buttons */}
            <div className="pt-4 border-t border-gray-200 dark:border-gray-700 space-y-2">
              <button
                onClick={() => {
                  const queryString = buildQueryString(filters, 0).replace('&page=0', '').replace('page=0', '');
                  window.location.href = `/api/export/csv?${queryString}`;
                }}
                className="w-full px-4 py-2 text-sm font-medium text-white bg-green-600 hover:bg-green-700 rounded-lg shadow-sm transition-colors"
              >
                Export to CSV ({resultsCount} papers)
              </button>
              <button
                onClick={() => {
                  navigator.clipboard.writeText(window.location.href);
                  alert('Link copied to clipboard!');
                }}
                className="w-full px-4 py-2 text-sm font-medium text-gray-700 dark:text-gray-300 bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 rounded-lg transition-colors"
              >
                Copy Shareable Link
              </button>
            </div>
          </div>
        </div>
      );
    };


    /**
     * Pagination controls
     */
    const Pagination = ({ currentPage, totalPages, onPageChange }) => {
      // Don't show pagination if there's only one page
      if (totalPages <= 1) {
        return null;
      }

      return (
        <div className="flex items-center justify-between mt-6">
          <button
            onClick={() => onPageChange(currentPage - 1)}
            disabled={currentPage === 0}
            className="px-4 py-2 text-sm font-medium text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 rounded-lg shadow-sm disabled:opacity-50 disabled:cursor-not-allowed hover:bg-gray-50 dark:hover:bg-gray-700"
          >
            ‚óÄ Prev
          </button>
          <span className="text-sm text-gray-600 dark:text-gray-400">
            Page {currentPage + 1} of {totalPages}
          </span>
          <button
            onClick={() => onPageChange(currentPage + 1)}
            disabled={currentPage === totalPages - 1}
            className="px-4 py-2 text-sm font-medium text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 rounded-lg shadow-sm disabled:opacity-50 disabled:cursor-not-allowed hover:bg-gray-50 dark:hover:bg-gray-700"
          >
            Next ‚ñ∂
          </button>
        </div>
      );
    };




    /**
     * Custom hook for managing bookmarks in localStorage
     */
    const useBookmarks = () => {
      const [bookmarks, setBookmarks] = useState(() => {
        const saved = localStorage.getItem('paper_bookmarks');
        return saved ? new Set(JSON.parse(saved)) : new Set();
      });

      useEffect(() => {
        localStorage.setItem('paper_bookmarks', JSON.stringify([...bookmarks]));
      }, [bookmarks]);

      const toggleBookmark = (arxivId) => {
        setBookmarks(prev => {
          const newSet = new Set(prev);
          if (newSet.has(arxivId)) {
            newSet.delete(arxivId);
          } else {
            newSet.add(arxivId);
          }
          return newSet;
        });
      };

      const isBookmarked = (arxivId) => bookmarks.has(arxivId);

      return { bookmarks, toggleBookmark, isBookmarked };
    };

    /**
     * Custom hook for managing reading lists in localStorage
     */
    const DEFAULT_LISTS = ['To Read', 'Reading', 'Completed'];

    const useReadingLists = () => {
      const [readingLists, setReadingLists] = useState(() => {
        const saved = localStorage.getItem('reading_lists');
        if (saved) {
          return JSON.parse(saved);
        }
        // Default structure: { listName: [arxivId1, arxivId2, ...] }
        return DEFAULT_LISTS.reduce((acc, name) => {
          acc[name] = [];
          return acc;
        }, {});
      });

      useEffect(() => {
        localStorage.setItem('reading_lists', JSON.stringify(readingLists));
      }, [readingLists]);

      const addToList = (arxivId, listName) => {
        setReadingLists(prev => {
          const updated = { ...prev };
          // Remove from all lists first
          Object.keys(updated).forEach(list => {
            updated[list] = updated[list].filter(id => id !== arxivId);
          });
          // Add to the selected list
          if (listName && updated[listName]) {
            updated[listName] = [...updated[listName], arxivId];
          }
          return updated;
        });
      };

      const removeFromList = (arxivId, listName) => {
        setReadingLists(prev => ({
          ...prev,
          [listName]: prev[listName].filter(id => id !== arxivId)
        }));
      };

      const getListForPaper = (arxivId) => {
        for (const [listName, papers] of Object.entries(readingLists)) {
          if (papers.includes(arxivId)) {
            return listName;
          }
        }
        return null;
      };

      const getListNames = () => Object.keys(readingLists);

      const getListCount = (listName) => readingLists[listName]?.length || 0;

      return { readingLists, addToList, removeFromList, getListForPaper, getListNames, getListCount };
    };

    /**
     * Helper to build query strings
     */
    const buildQueryString = (filters, page) => {
      const params = new URLSearchParams();

      if (filters.search) params.append('search', filters.search);
      if (filters.author) params.append('author', filters.author);
      if (filters.dateFrom) params.append('dateFrom', filters.dateFrom);
      if (filters.dateTo) params.append('dateTo', filters.dateTo);
      filters.selectedCategories.forEach(cat => {
        params.append('category', cat);
      });
      if (filters.onlySummarized) params.append('onlySummarized', 'true');
      if (filters.minScore > 0) params.append('minScore', filters.minScore);
      if (filters.onlyScored) params.append('onlyScored', 'true');
      if (filters.sort) params.append('sort', filters.sort);
      if (page) params.append('page', page);

      return params.toString();
    };




    /**
     * Main App Component
     */
    function App() {
      // --- Dark Mode with localStorage persistence ---
      const [darkMode, setDarkMode] = useState(() => {
        const saved = localStorage.getItem('darkMode');
        if (saved !== null) return JSON.parse(saved);
        return window.matchMedia('(prefers-color-scheme: dark)').matches;
      });

      // Apply dark mode class to document
      useEffect(() => {
        if (darkMode) {
          document.documentElement.classList.add('dark');
        } else {
          document.documentElement.classList.remove('dark');
        }
        localStorage.setItem('darkMode', JSON.stringify(darkMode));
      }, [darkMode]);

      // Bookmarks hook
      const { bookmarks, toggleBookmark, isBookmarked } = useBookmarks();

      // Reading lists hook
      const { readingLists, addToList, getListForPaper, getListNames, getListCount } = useReadingLists();

      // Parse initial filters from URL
      const getInitialFilters = () => {
        const params = new URLSearchParams(window.location.search);
        return {
          search: params.get('search') || '',
          author: params.get('author') || '',
          dateFrom: params.get('dateFrom') || '',
          dateTo: params.get('dateTo') || '',
          selectedCategories: new Set(params.getAll('category')),
          onlySummarized: params.get('onlySummarized') === 'true',
          minScore: parseInt(params.get('minScore') || '0', 10),
          onlyScored: params.get('onlyScored') === 'true',
          onlyBookmarked: false,  // Local only, not in URL
          selectedList: null,     // Reading list filter, local only
          sort: params.get('sort') || 'score',
        };
      };

      const [filters, setFilters] = useState(getInitialFilters);

      const [currentPage, setCurrentPage] = useState(() => {
        const params = new URLSearchParams(window.location.search);
        return parseInt(params.get('page') || '0', 10);
      });

      // Update URL when filters or page change
      useEffect(() => {
        const queryString = buildQueryString(filters, currentPage);
        const newUrl = queryString ? `?${queryString}` : window.location.pathname;
        window.history.replaceState(null, '', newUrl);
      }, [filters, currentPage]);

      // --- State for Fetched Data ---
      const [papers, setPapers] = useState([]);
      const [allCategories, setAllCategories] = useState([]);
      const [totalPages, setTotalPages] = useState(1);
      const [resultsCount, setResultsCount] = useState(0);
      const [isLoading, setIsLoading] = useState(true);


      // --- Fetch Categories on Load ---
      useEffect(() => {
        // Fetch the categories for the filter sidebar
        fetch('/api/categories')
          .then(res => res.json())
          .then(data => {
            setAllCategories(data);
          })
          .catch(err => console.error("Failed to fetch categories:", err));
      }, []); // Empty array means run once on component mount


      // --- Fetch Papers when Filters or Page Change ---
      useEffect(() => {
        setIsLoading(true);
        const queryString = buildQueryString(filters, currentPage);

        // We use a small timeout to allow the "page reset" to happen first
        // if filters changed. This prevents fetching the wrong page.
        const timer = setTimeout(() => {
          fetch(`/api/papers?${queryString}`)
            .then(res => res.json())
            .then(data => {
              setPapers(data.papers);
              setTotalPages(data.total_pages);
              setResultsCount(data.results_count);
              setIsLoading(false);
            })
            .catch(err => {
              console.error("Failed to fetch papers:", err);
              setIsLoading(false);
            });
        }, 10); // 10ms delay

        return () => clearTimeout(timer); // Cleanup timer

      }, [filters, currentPage]); // Re-run this effect when filters or page change


      // --- Reset page to 0 when filters change ---
      // We listen to a stringified version of the filters, *except* for search,
      // which is handled by its debouncer.
      const filtersForPageReset = { ...filters };
      delete filtersForPageReset.search; // Search doesn't reset page

      useEffect(() => {
        setCurrentPage(0);
      }, [JSON.stringify(filtersForPageReset), filters.search]); // Reset page if filters change




      // Handle page change
      const handlePageChange = (newPage) => {
        if (newPage >= 0 && newPage < totalPages) {
          setCurrentPage(newPage);
          // Scroll to top when page changes
          window.scrollTo(0, 0);
        }
      };


      return (
        <div className="flex flex-col md:flex-row min-h-screen bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-white">
          {/* Sidebar */}
          <FilterSidebar
            filters={filters}
            setFilters={setFilters}
            allCategories={allCategories}
            resultsCount={resultsCount}
            darkMode={darkMode}
            setDarkMode={setDarkMode}
            bookmarkCount={bookmarks.size}
            listNames={getListNames()}
            getListCount={getListCount}
          />

          {/* Main Content */}
          <main className="flex-1 p-5 md:p-8 min-w-0">
            {/* We show pagination controls even if loading */}
            <Pagination
              currentPage={currentPage}
              totalPages={totalPages}
              onPageChange={handlePageChange}
            />

            {isLoading && (
              <div className="flex justify-center items-center h-64">
                <p className="text-lg text-gray-500">Loading papers...</p>
              </div>
            )}

            {!isLoading && papers.length > 0 ? (
              <>
                {/* Paper List */}
                <div className="grid grid-cols-1 gap-6 mt-6">
                  {papers
                    .filter(paper => !filters.onlyBookmarked || isBookmarked(paper.arxiv_id))
                    .filter(paper => !filters.selectedList || getListForPaper(paper.arxiv_id) === filters.selectedList)
                    .map(paper => (
                      <PaperCard
                        key={paper.id}
                        paper={paper}
                        isBookmarked={isBookmarked(paper.arxiv_id)}
                        onToggleBookmark={toggleBookmark}
                        currentList={getListForPaper(paper.arxiv_id)}
                        listNames={getListNames()}
                        onSelectList={addToList}
                      />
                    ))}
                </div>

                {/* Bottom Pagination Controls */}
                <Pagination
                  currentPage={currentPage}
                  totalPages={totalPages}
                  onPageChange={handlePageChange}
                />
              </>
            ) : null}

            {!isLoading && papers.length === 0 && (
              <div className="flex items-center justify-center h-64">
                <div className="text-center p-12 bg-white dark:bg-gray-800 rounded-lg shadow-md">
                  <h3 className="text-xl font-semibold text-gray-700 dark:text-gray-300">No Results Found</h3>
                  <p className="mt-2 text-gray-500 dark:text-gray-400">
                    Try clearing some filters or broadening your search.
                  </p>
                </div>
              </div>
            )}
          </main>
        </div>
      );
    }

    // 6. Get the root element and render the App
    const container = document.getElementById('root');
    const root = ReactDOM.createRoot(container);
    root.render(<App />);


  </script>


</body>

</html>